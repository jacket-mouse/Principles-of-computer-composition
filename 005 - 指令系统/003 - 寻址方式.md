目的：确定本条指令的操作数地址 and 下一条欲执行指令的指令地址
# 指令寻址

下一条欲执行指令的指令地址

- 顺序 （PC）+ 1 -> PC
- 跳跃 由转移指令指出
# 数据寻址

确定本条指令的操作数地址
指令依旧是两部分：操作码和地址码，只不过操作码被细分了。

| 操作码 | 寻址特征 | 形式地址A |
| ---- | ---- | ---- |
约定：指令字长 = 存储字长 = 机器字长
形式地址：指令字结构中给定的地址，需要根据寻址特征对该地址进行进一步计算才能得到实际地址，从而获取操作数
有效地址：操作数的真实地址
## 立即寻址

形式地址A就是操作数
立即寻址特征：#

| OP  | #   | A   |
| --- | --- | --- |
| 操作码    | 立即寻址特征    | 立即数（补码，可正可负）    |
**特点**
- 指令执行阶段不访存
- A的位数限制了立即数的取值范围

## 直接寻址

EA = A 有效地址 = 形式地址（绝对地址）

!()[Photo/20240104224026.png]
**特点**
- 执行阶段访问一次存储器
- A的位数决定了该指令操作数的寻址范围
- 操作数的地址不易修改
## 隐含寻址（不考）

操作数地址隐含在操作码或某个寄存器中
![[Photo/20240104224315.png]]
**举例**
8086
- MUL指令：被乘数隐含在 AX（16位）或 AL（8位）中
- MOVS指令：源操作数的地址隐含在 SI 中；目的操作数的地址隐含在 DI 中
**特点**
- 指令字中少了一个地址字段，可缩短指令字长
## 间接寻址

EA = （A） 有效地址由形式地址间接提供
寻址特征：@
![[Photo/20240104224617.png]]
**编程举例：**
![[Photo/20240104224701.png]]
**特点**
- 执行指令阶段访问2次存储器
- 可扩大寻址范围
- 便于编制程序
## 寄存器寻址

EA = Ri 有效地址为寄存器编号
![[Photo/20240104224759.png]]
**特点**
- 执行阶段不访存，只访问寄存器，执行速度快
- 寄存器个数有限，可缩短指令字长

## 寄存器间接寻址

EA = （Ri）有效地址就在寄存器里
![[Photo/20240104224931.png]]
**举例**
若指令中给出寄存器号为001（R1），按寄存器间址方式读取操作数。
![[Photo/20240104225138.png]]
((R1)) = (2000H) = 2C00H
**特点**
- 有效地址在寄存器中，操作数在存储器中，执行阶段访存
- 有利于在指令字长有限的情况下，扩大寻址范围
## 基址寻址

1. 采用专用寄存器作为基址寄存器
	EA = ( BR ) + A        BR为基址寄存器（隐式）
	![[Photo/20240104225819.png]]
	**特点**
	- 可扩大寻址范围
		- 一条大指令，BR提供指令头，A提供指令变的部分，经过ALU合成一条长指令。
	- 有利于多道程序
	- BR内容由操作系统或管理程序确定（调入内存时）
	- 在程序的执行过程中BR的内容不变
2. 采用通用寄存器作基址寄存器
	![[Photo/20240104230156.png]]
	**特点**
	- 用户指定由哪个通用寄存器
	- 基址寄存器的内容由操作系统确定
	- 在程序的执行过程中R0内容不变
## 变址寻址

EA = ( IX ) + A        IX为变址寄存器（专用） 通用寄存器也可作为变址寄存器
![[Photo/20240104230523.png]]
**特点**
 - 可扩大寻址范围
 - IX的内容由用户给定
 - 在程序的执行过程中IX内容可变，形式地址A不变
 - 便于处理数组问题
	 - A存4（int长度）IX存数组起始地址，然后在ALU中加4，找到第一个元素，IX变化，再加4，第二个元素……
 
## 变址寻址与基址寻址的异同点

//变址和基址指的是寄存器内的数变不变

- 相同点：二者都可有效地扩大指令寻址范围。
- 不同点：
	- 二者的使用方式不同。
		- 变址寻址方式：指令提供基准量不变， R提供修改量可变；适于处理一维数组。
		- 基址寻址方式：基址指令提供位移量(不变)， R提供基准量(可变)；适用于扩大有限字长指令的访存空间(说明：准确理解教科书上的描述--P315）。
	- 二者的应用目的不同。
		- 变址寻址方式面向用户，用于对成批数据的连续的便捷访问；
		- 基址寻址方式面向系统，用来解决程序在实际主存中重定位问题（为程序分配存储空间）及扩大访存空间；

## 相对寻址

EA = ( PC ) + A（说明：当前PC的值，已经完成取指）
寻址特征：*
A 是相对于当前指令的位移量（可正可负，补码）
![[Photo/20240104231421.png]]
**按字节寻址的相对寻址举例**
![[Photo/20240104231541.png]]
设当前指令地址 PC = 2000H
转移后的目的地址为 2008H
因为 取出JMP *  + 8 后，PC = 2002H（PC自动加1）
故 JMP * + 8 指令的第二字节为2008H - 2002H = 06H
**特点**
- A的位数决定操作数（或目标指令）的寻址范围
- 有利于程序的浮动
- 广泛用于转移指令

**典型例题（结合小端法&符号位扩展）**

例题7.2    设相对寻址的转移指令占3个字节，第一字节为操作码，**第二、三字节为相对位移量（补码表示）**，而且数据在存储器中采用以低字节地址为字地址的存放方式（小端法）。每当CPU从存储器取出一个字节时，即自动完成（PC）+1 → PC。
**1）若PC当前值为240（十进制），要求转移到290（十进制），则转移指令的第二、三字节的机器代码是什么？**
	290 - 243 = 47 -> 两个字节的二进制代码
	- 单字节 -> 双字节（补码）
		- 符号位0 -> 全补0
		- 符号位1 -> 全补1
	47 = 0010 1111 符号位0 = 0000 0000 0010 1111 = 00 2FH
	小端法存放：	
		第二字节 = 0010 1111
		第三字节 = 0000 0000 

**2）若PC当前值为240，要求转移到200，则转移指令的第二、三字节的机器代码是什么？**
	200 - 243 = -43
	-43  = 1101 0101 = 1111 1111 1101 0101
	第二字节 = 1101 0101
	第三字节 = 1111 1111

设相对寻址的转移指令占两个字节，第一个字节是操作码，第二个字节是相对位移量，用补码表示。假设当前转移指令第一字节所在的地址为2000H，且CPU每取出一个字节便自动完成（PC）+ 1 → PC的操作。试问当执行“JMP  \*+ 8”和“JMP  \*- 9”指令时，转移指令第二字节的内容各为多少？加一问：操作数的有效地址是多少？
**确定相对位移量 = 转移目标地址 - 修正后的PC值**
当前指令字中的+8和-9的含义是什么？
**转移到的目标地址和指令地址（未修正前的PC值）之间的距离。**

某机器字长16位,主存按字节编址,转移指令采用相对寻址,由两个字节组成,第一字节为操作码字段,第二字节为相对位移量字段.假定取指令时,每取一个字节PC自动加1.若某转移指令所在主存地址为2000H,相对位移量字段的内容为06H,则该转移指令成功转移后的目标地址是2008H。
	2000H OP （未修正前的PC值）
	2001H 06H
	2002H （修正后的PC值）
	转移目标地址 = 相对位移量 + 修正后的PC值 = 2002H + 0006H = 2008H

## 堆栈寻址
### 堆栈的特点

堆栈
- 硬堆栈：多个寄存器
- 软堆栈：指定的储存空间
后进先出（LIFO，一个出入口）栈顶地址由SP指出
进栈：( SP ) - 1 -> SP
出栈：( SP ) +1 -> SP
![[Photo/20240105110318.png]]
向下为地址增加的方向