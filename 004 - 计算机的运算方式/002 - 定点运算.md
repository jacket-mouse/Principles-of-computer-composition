
# 移位运算

- 左移：绝对值扩大
- 右移：绝对值缩小

## 移位规则

- **以原码的规则为基础延伸。**
- 符号位不变
- 正数

原码、补码、反码不论左移、右移都补0

- 负数
    1. 原码：不论左移、右移都不0
    2. 补码：左移补0，右移补1
        1. **解释左移补0：**同原码一样，补码需要原码按位取反加一得到，有一个取反和加一的过程，但该过程不会影响移位运算，可以不考虑（即，取反加一之前移位，之后也会相应的移位；之后移位，之前也会相应移位），按照原码移位规则就是补0；
        2. 记忆左移补0：只有左移补0，0会取反变成1，然后再加1，因为它是左边第一位，肯定能加上，又变成0，最左边的那一位才会是0，而不是1，这样转化为真值时，才是偶数，而非有加1的奇数。
        3. 课本解释补码移位规则：分析任意补码得，补码由低位向高位找1，第一个1左边的部分与反码相同，1右边部分与原码相同，所以左移，空出右边的原码部分，要补0；右移，空出左边反码部分，要补1
        4. 分析该“1”：1取反为0，会阻碍掉加的那个1，所以1左边不受波及，只用取反，同反码；右边部分，取反还要加1，变成原码
    3. 反码（不常见）：不论左移、右移都补1
        1. 解释：反码除符号位都与原码相反，故不论左移右移都补1

## 移位分类

- 逻辑移位：无符号数的移位，表示的全为非负数，非常简单粗暴，左移、右移都直接补0就可以，位数全都可以移位。
- 算术移位：有符号数的移位，有原码、补码、反码的区分，根据不同移位规则不同，并且符号位不参与移位。

# 加减法运算

## 补码加减运算公式

运算时 — 补码可以连同符号位一起运算，直接列竖式计算即可，不用像乘除法那样写详细步骤。

- 加法
    
    - 整数 取模的作用是去掉最高位的进位
    $$ [A]_补+[B]_补=[A+B]_补（{mod}\ 2^{n+1}） $$
    
    - 小数
        $$ [A]_补+[B]_补=[A+B]_补（{mod}\ 2） $$
        
- 减法（加负数）
    
    - 整数
    $$ [A-B]_补=[A+(-B)]_补=[A]_补+[-B]_补（{mod}\ 2^{n+1}） $$
    
    - 小数
    $$ [A-B]_补=[A+(-B)]_补=[A]_补+[-B]_补（{mod}\ 2） $$
    

### 硬件配置和逻辑实现

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/cc0b425d-d4af-4a28-ae6d-53df8aba0f4a/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/02a1e5cc-0896-414b-b2af-5df40f4678f3/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/907f7e2c-586c-4423-8701-40d8cfb0a2b2/Untitled.png)

**加法：X=X+Y**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/1a7fd413-f72c-465e-ad4f-c69c0125e879/Untitled.png)

**减法：X=X-Y**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/01563278-5924-465a-84cc-c6b76804361e/Untitled.png)

## 溢出判断

概念：运算结果超出结果数据类型的表示范围，称为溢出(overflow)。 
	正溢：超过最大正数 
	负溢：超出最小负数

## 造成溢出的情况

1. 小数加法运算→得到大于一的数
2. 整数运算→超出整数表示范围
3. 正负数相加→不可能溢出

## 溢出判断分类

### 一位符号位判溢出

1. 参与加法操作的 两个数符号相同，其结果的符号与原操作数的符号不同，即为溢出

$$ Overflow=\bar{S_A}\bar{S_B}S_F+S_AS_B\bar{S_F}\ (减法转为加法看待) $$

> 满足前一半为正溢 满足后一半为负溢

注：S_A、S_B分别为两操作数的符号位；S_F为结果的符号位

$$ Overflow={C_f}\oplus{C} $$

> C=1，Cf =0为正溢； C=0，Cf =1为负溢；(负溢：本来是1才能在最高位不进位的情况下进位，变成正数， 实现负溢 正溢：反之。)

注：Cf:符号位产生的进位；C:最高数值位向符号位的进位

### 两位符号位判溢出

（双符号位）将符号位扩展为两位，信息量扩大，就能判明是否有溢出以及结果的符号。

$$ Overflow=S_{f1}\oplus{S_{f2}} $$

> 说明：若两个符号位不一致时表明溢出。不论是否产生溢出，高位符号位即真正的符号位。

> 00－结果为正，无溢出； 01－结果正溢； 10－结果负溢； 11－结果为负，无溢出。

注：S_f1和S_f2分别为高为符号位和低位符号位

### Q&A

**Q：**题目中只说有一个符号位，我们是否可以用两个符号位，假设可以用两个符号位，而多的那一位会不会占用数值位的位数？

> 假设机器是6位，1位符号位和5位数值位，其实存储的时候，是只存六位的，符号位为两个符号位里的高位。而运算时，运算部件会设计的多一位，变成7位，两个符号位都会进行运算。

### 总结

以上三种溢出判断方法，都是异曲同工，可以相互推之。

---

# 乘法运算

乘/除运算不能像补码加减一样统一处理，只能分别处理。

## 分析过程

通过笔算（列竖式），观察运算过程。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/584d0c6d-e33a-488b-a640-e34729d2e381/Untitled.png)

### 概念

1. 初始部分积：00000000……
2. 部分积：初始部分积+位积→新的部分积→右移一位+位积→新的部分积→右移一位+……
3. 位积：0或被乘数，例：1101（被乘数）、1101、0000、1101

### 提出问题

1. 符号问题（符号位的处理）
2. 多项部分积相加，进位传递问题（由于加法器等硬件的限制，只能两位两位的运算，而不能多个数据同时运算）
3. 加法器的位数通常和寄存器位数相同（乘积的字长扩展了一倍，如何存放？）

### 解决问题

1. 符号位：定点原码乘法，符号位单独处理；定点补码乘法，符号位可以直接运算。
2. 采用2种乘法器：一种方法就是采用阵列乘法电路实现；另一种是：将n位乘转换为n次累加和n次移位，这种乘法需分解为多步实现，依靠时序控制分步，称为时序控制乘法器。
    1. 把一次求和的操作，变成逐步累加求部分积的操作
    2. 将求积过程中逐位按权左移位积的操作，改为位积不动，而是上次部分积右移的操作
3. 通过将不再累加的乘积低位右移，则加法器的位数无需扩充

## 实现方案

1. 对速度要求不高的机器，用软件实现：通过加法（或减法）及移位分为多步实现，缺点是速度较慢；
2. 使用乘除运算较多，速度要求高时，通过专门逻辑电路实现，但硬件代价较大，如阵列乘法器和阵列除法器；
3. 一般情况，配置乘除法可选件。

## 运算过程

1. 原码一位

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/41dd5cf8-b357-44b0-8533-a4249432fc2b/Untitled.png)

## 总结

1. 乘法运算可用加法和移位实现　若n = 4（乘数的位数），加4次，移4次
2. 由乘数的末位决定被乘数是否与原部分积相加，然后→1位形成新的部分积，同时乘数→1位　（末位移丢），空出高位存放部分积的低位。
3. 硬件配置：3个寄存器，其中A、C具有移位功能 1个全加器，**1个计数器（统计运算次数，及时停止运算）**

## 原码一位乘

以小数为例

$[x]_原 = x_0.x_1x_2x_3……x_n$

$[y]_原 = y_0.y_1y_2y_3……y_n$

$$ [x·y]_原=（0.x_1x_2x_3……x_n）(0.y_1y_2y_3……y_n)=(x_0\oplus{y_0}).x^_·y^_ $$

$x^*=0.x_1x_2x_3……x_n$ 代表x的绝对值

$y^*=0.y_1y_2y_3……y_n$ 代表y的绝对值

$x_0\oplus{y_0}$ 符号部分单独处理

### 递推公式

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/a28fb421-33cc-4c8b-8f78-36dd6b86160b/Untitled.png)

### 硬件配置

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/a5bc0bf7-4bba-4ec7-be01-618cb100d382/Untitled.png)

## 原码两位乘（自学）

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/bbbf5a8a-3c19-4c8e-b991-d0af152eab55/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/6691e782-327d-441d-8b11-90b263e1fff1/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/18f98017-d1e6-4049-aaaa-a9a17581be08/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/96a96f46-a001-41a8-aaee-764686d4b874/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/dbda7ff5-fe77-4483-87f0-e5f92ef4f4b4/Untitled.png)

## 补码一位乘

诞生原因：同一运算部件对加减运算采用补码，而对乘法又用原码，就得进行码制转换，因而不太方便。

实现补码乘法有如下结论(本处不证明)：

### 校正法：

1. 若乘数Y为正，不管被乘数X符号，则有：

$$ [X·Y]_补=[X]_补[Y]_补 $$

1. 若乘数Y为负，则先按原码乘法运算（加和移位按补码运算），结果再加一个校正量-[X]补， 即：

$$ [X·Y]_补=[X]_补[0.Y_1Y_2……Y_n]_补-[X]_补 $$

### Booth算法

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/f5fb9cd0-732d-4906-ae3d-b633e9412cf9/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/90de0425-541d-4532-998e-4d7e100b0025/Untitled.png)

### 硬件配置

实现补码Booth算法的运算器框图如下图所示。图中全加器和寄存器均为n+2位。

A寄存器存放部分积，含两位符号位，初态为“0”;

X寄存器存放被乘数的补码，含两位符号位;

Q寄存器存放乘数的补码，含1位符号位，最末位为附加位，初态为“0”。

最终乘积的高位在寄存器A中，乘积的低位在Q寄存器中。计数器C用来控制移位次数，判断乘法是否结束。G_M为乘法标记

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/82a12bed-b59e-4609-863b-d9f5b88f22d3/Untitled.png)

## 原码乘法与补码乘法的不同

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/f004273f-4e5d-4738-ada6-c9ce4e2d1859/Untitled.png)

## 总结

1. 整数乘法与小数乘法完全相同，可用逗号代替小数点。
2. 将乘法运算转化为加法和移位运算，硬件成本较低，但运算速度较慢。
3. 不同的乘法运算需有不同的硬件支持，阵列乘法器运算速度快，但硬件成本较高。（见教材附录6B）

# 除法运算

## 机器除法

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/821cc9b5-246c-4306-a5a6-dd2339b67bbd/Untitled.png)

## 原码除法

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/9876a337-8e4f-428c-8a58-942f92dd5a7b/Untitled.png)

### 恢复余数法&不恢复余数法（加减交替法）

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/8ad07270-275d-4325-80cc-507b974983c5/Untitled.png)

### 加减交替除法硬件配置

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/92f5de13-3016-41ab-93e3-8c8d75913a18/3622bae3-ce4e-4bfc-96cb-1a71956114d7/Untitled.png)

## 补码除法（自学）