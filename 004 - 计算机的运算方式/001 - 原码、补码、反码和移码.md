
# 进制数

## 符号

1. 9BH：H代表Hex，十六进制
2. B：Bin，二进制
3. D：Dec，十进制
## 进制转换
### 十进制转二进制（任意进制）

**整数部分：**
除基取余法（先得为低位）
以100为例
	100 / 2  = 50 …… 0
	50 / 2  = 25 …… 0
	25 / 2 = 12 …… 1
	12 / 2 = 6 …… 0
	6 / 2 = 3 …… 0
	3 / 2 = 1 …… 1
	1 
1100100H = 100D

**小数部分：**
乘基取整法（先得为高位）
以0.3为例：
	0.3 * 2 = 0.6 …… 0
	0.6 * 2 = 1.2 …… 1
	0.2 * 2 = 0.4 …… 0
	0.4 * 2 = 0.8 …… 0
	0.8 * 2 = 1.6 …… 1
	………………………………
约为0.0 1001 1001 1001 1001……

### 任意进制转十进制

按权相加得到的数就为十进制数
以二进制为例：
	1011 = 1 + 2 + 8 = 11

### 二进制转八进制

1000 1010 1001 = 100 010 101 001 = 4251（八进制）
### 二进制转十六进制

1000 1010 1001 = 8A9H

# 原码

原码 = 符号位 + 绝对值（二进制）
正数原码符号位为0；负数原码符号位为1，绝对值是相同的。
## 整数

![[Pasted image 20240103154744.png]]
x：真值
n：整数的位数，但不是十进制形式的位数，而是二进制形式下的位数。
符号位和绝对值之间要通过**逗号**隔开。
通过定义可以看出0的原码有两种表示形式：
	+0：0,000 0000（逗号后0的数量是不固定的，下面也是）
	-0： 1,000 0000
## 小数

![[Pasted image 20240103154713.png]]
符号位和绝对值之间要通过**点号**隔开。

# 补码
## 整数

![[Pasted image 20240103155158.png]]

## 小数

![[Pasted image 20240103155618.png]]
**注意**
- 当真值为负数时，补码可用原码符号位不变，数值位按位取反+1得到。（过程可逆：补码按位取反+1也能得到原码）
- 补码的正负数转化，并不仅仅是只换符号位。因为，正数原码和补码是一样的，负数原码需要按位取反加一才能转为补码。
- **0的补码只有一种。**
	- 根据定义，我们可以看到0只能存在一种表示，即0,000 0000
	- 根据原码转化，
		- +0：0,000 0000 -> 0,000 0000
		-  -0：1,000 0000 -> 10,000 0000最高位被舍掉了，所以还是 0,000 0000
- 补码在负数方向上比原码稍宽（多表示一个数）
       对于定点小数，可表示-1
       对于定点整数，可表示$-2^n$ 

# 反码
## 整数

![[Pasted image 20240103160546.png]]

## 小数

![[Pasted image 20240103160603.png]]

- 对于正数，符号位为0，且有：原码 = 补码 = 反码 
- 对于负数 ，符号位为 1，其数值部分：
	原码的数值位和真值相同
	原码的数值位按位取反末位加 1 ->  补码
	原码的数值位按位取反 -> 反码
所以，反码也有两个0：
	+0：0,0000
	-0：1,0000 按位取反 1,1111

# 移码

![[Pasted image 20240103161209.png]]
x ：真值        n ：整数的位数
- 补码与移码只差一个符号位
	- 移码只有一个0：1,00000

# 定点数
## 带符号定点整数

S= $S_f S_1S_2S_3…S_{n-1}S_n$ (共n+1位，整数数值位为n)
- **原码**
	- 最小负数：-（$2^n$-1）    1,1...11
	- 最大负数：-1                    1,0...01
	- 最小正数：1                      0,0...01 
	- 最大正数： $2^n$-1               0,1...11
- **补码**
	- 最小负数：-（$2^n$）         1,0...00
	- 最大负数：-1                    1,1...11
	- 最小正数 ：1                     0,0...01
	- 最大正数： $2^n$-1               0,1...11
## 带符号定点小数

S= $S_0.S_1S_2S_3…S_{n-1}S_n$
- 原码
	- 最小负数：-（1-$2^{-n}$）     1.1...11
	- 最大负数：-$2^{-n}$                   1.0...01
	- 最小正数： $2^{-n}$                    0.0...01
	- 最大正数： 1-$2^{-n}$                0.1...11
- 补码
	- 最小负数：-1                        1.0...00
	- 最大负数： -$2^{-n}$                   1.1...11            
	- 最小正数： $2^{-n}$                     0.0...01
	- 最大正数： 1-$2^{-n}$                0.1...11

**上述的原码和补码只有最小负数有区别，因为补码能比原码多表示一位负数。**
# 浮点数

## 浮点数的表示
N = S * $r^j$
- S:尾数    j：阶码    r：基数（基值）
	- S 只能为小数、可正可负
	- j 只能为整数、可正可负

![[Pasted image 20240103163653.png]]
- Sf 代表浮点数的符号 
- n 其位数反映浮点数的精度
- m 其位数反映浮点数的表示范围
- jf  和 m 共同表示小数点的实际位置

## 浮点数的表示范围

- 上溢   阶码 > 最大阶码
- 下溢   阶码 ≤ 最小阶码   按**机器零**处理
## [浮点数规格化](https://blog.csdn.net/qq_44166630/article/details/115491716)

### 浮点数的规格化形式

- 尾数应为纯小数
- 尾数的值不为0时，其绝对值应大于等于十进制的0.5而小于1
- **两种特殊情况：**
	1. X=-1/2,[X]补=1.100…0不是规格化的数；
	2. X=-1，[X]补=1.00…0是规格化的数
### 浮点数的规格化

- 左规
- 右规



# 练习
## **分数的原码、反码、补码**

废话不多说，直接给出题目：求-35/64的原码、反码、补码。

**注意：左移右移的是小数点。**
![[Pasted image 20240102205326.png]]
```C++
令x=(- 35/64)_{10}=(-100011/1000000)_{2}=(-0.1000110)_{2}
缺位在后面补零，小数，权重是越往后越小的，和整数低位补零一样。
[x]原=1.1000110
[x]反=1.0111001
[x]补=1.0111010
[x]移=0.0111010（移码等于补码的符号位取反，其余位不变）
```




1. 在计算机系统中，数值一律用补码来表示（存储）。 主要原因： **使用补码，可以将符号位和其它位统一处理；** 同时，减法也可按加法来处理。 另外，两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。
2. 补码与原码的转换过程几乎是相同的。

**核心知识点：**

1. 正数的原码、反码和补码都相同；
2. 负数原码和反码的相互转换：符号位不变，数值位按位取反；
3. 负数原码和补码的相互转换：符号位不变，数值位按位取反,末位再加1；
4. 0的补码表示只有一种。

## -1的补码是怎么来的

设位数一共8位 原码表示范围为1.111 1111 ~0.111 1111，即-127/128到127/128 反码表示范围为1.000 0000~0.111 1111，即-127/128到127/128 补码表示范围为1.000 0000~0.111 1111，即-1到127/128 在这里原码和反码都好理解，就是补码会有一个问题，为什么补码会有一个1.000 0000而且居然对应的值是-1，也就是说如果小数用补码表示的话最小值是-1。这里如果用一开始说的取反加一你会发现根本不是这个值。之后才知道**取反加一靠的是原码**，**但看前面原码的定义公式你会发现原码根本表示不了定点小数-1，原码所能表示的是定点整数-1，定点小数-1这里严谨一点的话其实是-1.0。** 这里要求定点小数-1.0的补码的话就要用到上面的补码定义公式了，

_**由公式可知，-1.0的补码为2+X = 2-1.0 = 10.0000-1.0000=1.0000（课本P223）**_

总结：由于补码表示0的唯一性，补码比原码少一个-0的表示，多一个-1的表示以及负整数表示范围多了一个-128

## 浮点数原码取值范围

正负区间严格对称，求出正数取值，添负号即为负数区间。

1)应写出可表示范围的上、下限精确值(用   ≥或 ≤，不要用>或<)。 2)应用十进制2的幂形式分阶、尾两部分表示，这样可反映出浮点数的格式特点。括号不要乘开，不要用十进制小数表示，不直观、不精确且无意义。 3)原码正、负域对称，补码正、负域不对称，浮点数阶、尾也如此。特别要注意浮点负数补码规格化范围。(满足条件:数符 ⊕ M S B 位 = 1 )




