# 加减法运算

## 补码+双符号位判断

- 运算结果：
1. 正溢出：01，最高符号位为0
2. 负溢出：10：最高符号位为1
3. 算出正确结果

运算过程：

1. 将十进制数转化为原码
2. 将原码转化为双符号位补码形式
3. 代入定点加减法公式计算（列竖式）
4. 判断是否溢出，若溢出，点名正溢还是负溢后结束；若不溢出，算出的数是补码形式，应转化为十进制数

# 乘法运算

## 原码一位运算

运算步骤：

1. 将十进制数转化为原码形式（有的题目已经转换好）
2. 画三列表格（进行要乘的两个数的绝对值运算，符号位是在之后单独处理的，以列竖式的横线进行分隔）：
    1. 部分积：进行定点数加法运算，可分为三行：
        1. 上一部分积（右移后，第一行的初始部分积除外）：
        2. 位积：被乘数或0
        3. 新部分积（没右移）：
    2. 乘数：可分为两行：
        1. 乘数部分：与**上一部分积**对齐，并表标明该次所用的是乘数的哪一项：若0，则位积为0；若1，则位积为被乘数。
        2. 移位部分：与**新部分积**对齐，可与新部分积看作一体，构成当前完整的运算结果。
    3. 说明：一般可分为两行：
        1. +0或+x*：由位积决定，与位积对齐
        2. →1，得z_1……：与移位对齐（因为初始部分积没有移位，故有单独说明，初态z_0 = 0）
3. 处理符号位：异或运算
4. 总结：将符号位和绝对值运算结合，得到答案。

特殊说明：

1. 表格在进行绝对值运算时，符号位可能会被进位，这是正常的，这是只是临时借位，之后的右移操作会将符号位上的数移到数值位。
2. 最后一个乘数用完之后算出的新部分积，还要右移得到最终结果，此时说明只有一行，无+0或+x*
3. 最后一次移位，无论是从递推公式来看，还是直观上要将最后一位乘数移去，都是要移的。虽然有的时候用笔算乘法（四位×四位），会得到一个七位的数，这只是说明最高位是0罢了，得到的七位数权重仍是后七位，0占据最高位权重，有时候最高位有进位1，就不会有这种思考，会直接得到八位数，这一点和十进制数的乘法列式计算不太一样。（或可以这样理解，如果是整数相乘，在最高位补零对于结果无影响；若是小数相乘，由十进制得出，小数点后面的位数取决于被乘数和乘数小数点之后位数和，4+4=8）
4. 关于移位部分的问题，是先移位才有移位部分，顺序不要搞反。

![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048161.png)
![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048228.png)

以上是实际的解题过程，可参考。

## 补码一位乘法

- 经验教训：
	1. 在考试时，有运算到不知道什么时候停止的疑问。（因此，截止时是最初乘数的最高位移至倒数第二个数且利用它进行过一次运算--该运算不移位，这样最后的结果就是答案）
- 运算步骤：
1. 将乘数和被乘数，转化为补码形式，被乘数还要算出相反数的补码。
2. 画四列表格（进行要乘的两个数的乘法运算，符号位在补码形式下一同处理，以列竖式的横线进行分隔）：
    1. 部分积：进行定点数加法运算，可分为三行：
        1. 上一部分积（右移后，**要按照补码右移的规则正数补0，负数补1**，第一行的初始部分积除外）：
        2. 位积：被乘数或**被乘数的相反数**或0
        3. 新部分积（没右移）：
    2. 乘数：占两列，而且将乘数部分和移位部分合为一体，乘数部分：与**上一部分积**对齐，并表标明该次所用的是乘数的哪两项：根据作差结果（y_n+1 - y_n）决定位积
    3. 说明：一般可分为两行：
        1. +[X]补或+[-X]补或+0：由位积决定，与位积对齐
        2. →1：与移位对齐（因为初始部分积没有移位）
3. 总结：得到答案。

特殊说明：

1. 最后一步运算完成后，是不进行移位的。（由递推公式得到）
2. X取双符号位，乘数取单符号位，说明见定点乘法，补码一位乘。
3. 乘数最好将小数点给保留，见右下图。
4. 部分积在实际运算时，可能会产生像100.10100这样的数（右下图，只不过1直接不写了），这时最高位的1，会直接被抛弃掉，而不参与后续运算。原因：

![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048288.png)

![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048361.png)
# 除法运算

## 恢复余数法
![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048433.png)
![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048498.png)
## 加减交替法

### 原码

问题：

1. 为什么原码除法会引入补码

运算过程：

1. 将除数和被除数转化为原码形式，求出绝对值的补码，求出除数（y）绝对值的相反数的补码。
2. 画三列表格（进行要除的两个数的绝对值运算，符号位是在之后单独处理的，以列竖式的横线进行分隔）：
    1. 被除数（余数）：进行定点数加法运算，由$[y_补]或[-y_补]$参与运算（商为0加正的；商为1加负的）。
    2. 商：记录每一次的商，并跟着移位。
    3. 说明：很简单，见图。
3. 处理符号位：异或运算
4. 总结：将符号位和绝对值运算结合，得到答案。

特殊说明：

1. 首次加法运算固定是$[x_补]+[-y_补]$
2. **逻辑左移时，数值位上的数会移到符号位（移位后的符号位由原本在符号位右面的数决定）上**，数值位不是不参与移位的。
3. 算出的商为符号位+数值位位数之和停止。
4. 最后算出的结果是$[x/y]_原$如果想要$[x/y]$需要进一步转换。例：1.11000→-0.11000
![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131048579.png)]]
![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Computer-organization/202402131132967.png)
### 补码